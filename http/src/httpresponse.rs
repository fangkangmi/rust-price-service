use std::collections::HashMap;
use std::io::{Result, Write};

#[derive(Debug, PartialEq, Clone)]
pub struct HttpResponse <'a> {
    version: &'a str,
    status_code: &'a str,
    status_text: &'a str,
    headers: Option<HashMap<&'a str, &'a str>>,
    body: Option<Vec<u8>>,
}

impl <'a> Default for HttpResponse <'a> {
    fn default() -> Self {
        Self {
            version: "HTTP/1.1",
            status_code: "200",
            status_text: "OK",
            headers: None,
            body: None,
        }
    }
}

impl<'a> From<HttpResponse<'a>> for String {
    fn from(response: HttpResponse<'a>) -> String {
        let mut response_string = format!(
            "{} {} {}\r\n",
            response.version, response.status_code, response.status_text
        );

        if let Some(headers) = &response.headers {
            for (key, value) in headers {
                response_string.push_str(&format!("{}: {}\r\n", key, value));
            }
        }

        response_string.push_str("\r\n");

        if let Some(body) = &response.body {
            response_string.push_str(&String::from_utf8_lossy(body));
        }

        response_string
    }
}

#[allow(dead_code)]
impl<'a> HttpResponse<'a> {
    pub fn new(
        status_code: &'a str,
        headers: Option<HashMap<&'a str, &'a str>>,
        body: Option<Vec<u8>>,
     ) -> HttpResponse<'a> {
        let mut response: HttpResponse<'a> = HttpResponse::default();
        if status_code != "200" {
            response.status_code = status_code;
        };
        response.headers = match &headers {
            Some(h) => headers,
            None => {
                let mut h = HashMap::new();
                h.insert("Content-Type", "text/html");
                Some(h)
            },
        };
        response.status_text = match response.status_code {
            "200" => "OK",
            "404" => "Not Found",
            "400" => "Bad Request",
            "500" => "Internal Server Error",
            _ => "Internal Server Error",
        };

        response.body = body;
        response
    }

    pub fn send_response(&self, stream: &mut impl Write) -> Result<()> {
        let mut response = format!(
            "{} {} {}\r\n",
            self.version, self.status_code, self.status_text
        );

        if let Some(headers) = &self.headers {
            for (key, value) in headers {
                response.push_str(&format!("{}: {}\r\n", key, value));
            }
        }

        response.push_str("\r\n");

        stream.write(response.as_bytes())?;
        if let Some(body) = &self.body {
            stream.write(body)?;
        }

        Ok(())
    }

    fn version(&self) -> &str {
        self.version
    }

    fn status_code(&self) -> &str {
        self.status_code
    }

    fn status_text(&self) -> &str {
        self.status_text
    }

    fn headers(&self) -> String{
        let mut headers = String::new();
        if let Some(h) = &self.headers {
            for (key, value) in h {
                headers.push_str(&format!("{}: {}\r\n", key, value));
            }
        }
        headers
    }

    fn body(&self) -> String{
        match &self.body {
            Some(b) => String::from_utf8_lossy(b).to_string(),
            None => String::new(),
        }
    }
}


//generated by AI
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_response_struct_creation_200() {
        let response = HttpResponse::new("200", None, Some(b"Hello World".to_vec()));
        let mut expected_headers = HashMap::new();
        expected_headers.insert("Content-Type", "text/html");

        let response_expected = HttpResponse {
            version: "HTTP/1.1",
            status_code: "200",
            status_text: "OK",
                    headers: Some(expected_headers),
                    body: Some(b"Hello World".to_vec()),
        };
        assert_eq!(response, response_expected);
    }

    #[test]
    fn test_response_struct_creation_404() {
        let response = HttpResponse::new("404", None, None);
        let mut expected_headers = HashMap::new();
        expected_headers.insert("Content-Type", "text/html");
        let response_expected = HttpResponse {
            version: "HTTP/1.1",
            status_code: "404",
            status_text: "Not Found",
            headers: Some(expected_headers),
        body: None,
        };
        assert_eq!(response, response_expected);
    }

    #[test]
    fn test_response_struct_creation_with_headers_and_body() {
        let mut headers = HashMap::new();
        headers.insert("Content-Type", "application/json");
        let body = Some(b"{\"key\":\"value\"}".to_vec());
        let response = HttpResponse::new("200", Some(headers.clone()), body.clone());
        let response_expected = HttpResponse {
            version: "HTTP/1.1",
            status_code: "200",
            status_text: "OK",
            headers: Some(headers),
            body,
        };
        assert_eq!(response, response_expected);
    }

    #[test]
    fn test_response_struct_creation_with_custom_status() {
        let mut headers = HashMap::new();
        headers.insert("Content-Type", "application/json");
        let body = Some(b"{\"error\":\"not found\"}".to_vec());
        let response = HttpResponse::new("404", Some(headers.clone()), body.clone());
        let response_expected = HttpResponse {
            version: "HTTP/1.1",
            status_code: "404",
            status_text: "Not Found",
            headers: Some(headers),
            body,
        };
        assert_eq!(response, response_expected);
    }

    #[test]
    fn test_http_response_creation(){
        let response_expected = HttpResponse{
            version: "HTTP/1.1",
            status_code: "200",
            status_text: "OK",
            headers: {
                let mut h = HashMap::new();
                h.insert("Content-Type", "text/html");
                Some(h)
            },
            body: Some((&b"Hello World"[..]).to_vec()),
        };
        let http_string: String = response_expected.into();
        let actual_string = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\nHello World";
        assert_eq!(http_string, actual_string);
    }
}